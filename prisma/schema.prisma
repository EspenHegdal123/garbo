generator zod {
  provider = "prisma-zod-generator"
}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  /// wikidataId is our unique identifier to link to companies, also used to export to or import from wikidata
  wikidataId       String            @id
  name             String
  description      String?
  /// Company website URL
  url              String?
  /// A comment only visible for reviewers to help them work with the company data and remember important info about this company.
  internalComment  String?
  /// Tags to help categorize and filter companies
  tags             String[]
  lei              String?
  baseYear         BaseYear?
  goals            Goal[]
  industry         Industry?
  initiatives      Initiative[]
  reportingPeriods ReportingPeriod[]
}

/// Explicitly stated base year for comparable data
model BaseYear {
  id        String     @id @default(cuid())
  year      Int
  companyId String     @unique
  company   Company    @relation(fields: [companyId], references: [wikidataId], onDelete: Cascade)
  metadata  Metadata[]
}

/// Connecting a company to a specific industry and metadata
/// This also gives us the flexibility to add more ways to keep track of which industry a company belongs to.
model Industry {
  id                  String       @id @default(cuid())
  gicsSubIndustryCode String
  companyWikidataId   String       @unique
  company             Company      @relation(fields: [companyWikidataId], references: [wikidataId], onDelete: Cascade)
  industryGics        IndustryGics @relation(fields: [gicsSubIndustryCode], references: [subIndustryCode])
  metadata            Metadata[]
}

/// A table containing the standardised GICS codes for categorizing companies into various industries.
/// These are added by the DB seeding script.
model IndustryGics {
  subIndustryCode        String     @id
  subIndustryName        String
  subIndustryDescription String
  sectorCode             String
  sectorName             String
  groupCode              String
  groupName              String
  industryCode           String
  industryName           String
  industries             Industry[]
}

/// A reporting period is a timespan for accounting emissions as well as financial data
model ReportingPeriod {
  id        String     @id @default(cuid())
  startDate DateTime
  endDate   DateTime
  /// The year needs to be the same year as the endDate.
  year      String
  /// Save URLs to the sustainability- and potentially also the yearly report for this reporting period.
  /// This needs to be separate from the source URLs for each datapoint, since the data might be updated in a more recent report.
  /// At the same time, we also want to refer back to the actual reports from a given reporting period for comparisons.
  reportURL String?
  companyId String
  economy   Economy?
  emissions Emissions?
  metadata  Metadata[]
  company   Company    @relation(fields: [companyId], references: [wikidataId], onDelete: Cascade)

  @@unique([companyId, year])
}

/// Reported emissions for a specific reporting period
model Emissions {
  id                   String                @id @default(cuid())
  reportingPeriodId    String?               @unique
  biogenicEmissions    BiogenicEmissions?
  reportingPeriod      ReportingPeriod?      @relation(fields: [reportingPeriodId], references: [id], onDelete: Cascade)
  scope1               Scope1?
  scope1And2           Scope1And2?
  scope2               Scope2?
  scope3               Scope3?
  statedTotalEmissions StatedTotalEmissions?
}

/// This is used when companies only report a total number for either overall- or scope 3 emissions.
/// TODO: Maybe this should be simplified to just be a `statedTotal` property for the Emissions, and `statedTotal` for Scope3?
/// However, the main reason behind using a separate entity for StatedTotalEmissions is because then we can keep track of metadata
/// specifically for the stated totals from the report. For example if the company changes an incorrect statedTotal that does not match the actual calculated total.
/// Not sure if this is worth it, in this structure though. Might be too complicated.
model StatedTotalEmissions {
  id          String     @id @default(cuid())
  total       Float?
  scope3Id    String?    @unique
  unit        String
  emissionsId String?    @unique
  metadata    Metadata[]
  emissions   Emissions? @relation(fields: [emissionsId], references: [id], onDelete: Cascade)
  scope3      Scope3?    @relation(fields: [scope3Id], references: [id], onDelete: Cascade)
}

/// This is used when companies have bad reporting where they have combined scope 1+2 as one value
model Scope1And2 {
  id          String     @id @default(cuid())
  total       Float?
  emissionsId String?    @unique
  unit        String
  metadata    Metadata[]
  emissions   Emissions? @relation(fields: [emissionsId], references: [id], onDelete: Cascade)
}

/// Biogenic emissions are reported separately from scope 1-3
model BiogenicEmissions {
  id          String     @id @default(cuid())
  /// Sometimes companies break it down into scope 1-3 - however these should always be stored as a total number according to the GHG protocol.
  total       Float?
  unit        String
  emissionsId String?    @unique
  emissions   Emissions? @relation(fields: [emissionsId], references: [id], onDelete: Cascade)
  metadata    Metadata[]
}

model Scope1 {
  id          String     @id @default(cuid())
  total       Float?
  unit        String
  emissionsId String?    @unique
  metadata    Metadata[]
  emissions   Emissions? @relation(fields: [emissionsId], references: [id], onDelete: Cascade)
}

/// For scope 2 emissions, we choose either market-based, location-based or unknown (if the company didn't specify if mb or lb)
/// We generally prefer using market-based emissions, but if that doesn't exist we could use location-based ones, and finally unknown.
model Scope2 {
  id          String     @id @default(cuid())
  /// Market-based emissions
  mb          Float?
  /// Location-based emissions
  lb          Float?
  /// Unknown scope 2 emissions could be either market-based or location-based
  unknown     Float?
  unit        String
  emissionsId String?    @unique
  metadata    Metadata[]
  emissions   Emissions? @relation(fields: [emissionsId], references: [id], onDelete: Cascade)
}

model Scope3 {
  id                     String                @id @default(cuid())
  /// Sometimes, companies only report a total value for scope 3 emissions without disclosing the scope 3 categories.
  /// Other times, they might report both, but their stated total scope 3 emissions might be different than the actual sum of their scope 3 categories.
  /// To get around this, we separate statedTotalEmissions from the actual mathematical total that we summarize during runtime.
  emissionsId            String?               @unique
  statedTotalEmissionsId String?               @unique
  metadata               Metadata[]
  emissions              Emissions?            @relation(fields: [emissionsId], references: [id], onDelete: Cascade)
  categories             Scope3Category[]
  statedTotalEmissions   StatedTotalEmissions?
}

/// Details about scope 3 categories. Here's a list of valid categories and their names:
///
/// 1. purchasedGoods
/// 2. capitalGoods
/// 3. fuelAndEnergyRelatedActivities
/// 4. upstreamTransportationAndDistribution
/// 5. wasteGeneratedInOperations
/// 6. businessTravel
/// 7. employeeCommuting
/// 8. upstreamLeasedAssets
/// 9. downstreamTransportationAndDistribution
/// 10. processingOfSoldProducts
/// 11. useOfSoldProducts
/// 12. endOfLifeTreatmentOfSoldProducts
/// 13. downstreamLeasedAssets
/// 14. franchises
/// 15. investments
/// 16. other
model Scope3Category {
  id       String     @id @default(cuid())
  /// Int from 1-15 defining the scope 3 category.
  /// 16 is a special value for "other", which is not included in the GHG protocol,
  /// but useful to handle companies who invent their own scope 3 "categories".
  category Int
  total    Float?
  scope3Id String
  unit     String
  metadata Metadata[]
  scope3   Scope3     @relation(fields: [scope3Id], references: [id], onDelete: Cascade)
}

model Economy {
  id                String           @id @default(cuid())
  reportingPeriodId String?          @unique
  reportingPeriod   ReportingPeriod? @relation(fields: [reportingPeriodId], references: [id], onDelete: Cascade)
  employees         Employees?
  turnover          Turnover?
}

model Turnover {
  id        String     @id @default(cuid())
  value     Float?
  currency  String?
  economyId String     @unique
  metadata  Metadata[]
  economy   Economy    @relation(fields: [economyId], references: [id], onDelete: Cascade)
}

model Employees {
  id        String     @id @default(cuid())
  /// Number of employees
  value     Float?
  /// How the number of employees were calculated, e.g. Full-time equivalents (FTE) or similar.
  unit      String?
  economyId String?    @unique
  economy   Economy?   @relation(fields: [economyId], references: [id], onDelete: Cascade)
  metadata  Metadata[]
}

model Goal {
  id          String     @id @default(cuid())
  description String
  year        String?
  target      Float?
  baseYear    String?
  companyId   String
  company     Company    @relation(fields: [companyId], references: [wikidataId], onDelete: Cascade)
  metadata    Metadata[]
}

model Initiative {
  id          String     @id @default(cuid())
  title       String
  description String?
  year        String?
  scope       String?
  companyId   String
  company     Company    @relation(fields: [companyId], references: [wikidataId], onDelete: Cascade)
  metadata    Metadata[]
}

/// Every datapoint has associated metadata about who changed it, when, and using what source
model Metadata {
  id                     String                @id @default(cuid())
  /// The comment is used to add relevant information about why the datapoint looks like it does
  comment                String?
  source                 String?
  updatedAt              DateTime              @default(now()) @updatedAt
  /// The userId who last updated the associated datapoint
  userId                 String
  /// The userId who verified the associated datapoint.
  /// Should only be set after human verification, and null if it has not been verified.
  /// Verified datapoints should not be automatically updated by AI extracted or estimatated data, but always go through manual review going forward.
  verifiedByUserId       String?
  goalId                 String?
  initiativeId           String?
  scope1Id               String?
  scope2Id               String?
  scope3Id               String?
  scope1And2Id           String?
  reportingPeriodId      String?
  baseYearId             String?
  biogenicEmissionsId    String?
  statedTotalEmissionsId String?
  industryId             String?
  categoryId             String?
  turnoverId             String?
  employeesId            String?
  baseYear               BaseYear?             @relation(fields: [baseYearId], references: [id])
  biogenicEmissions      BiogenicEmissions?    @relation(fields: [biogenicEmissionsId], references: [id])
  category               Scope3Category?       @relation(fields: [categoryId], references: [id])
  employees              Employees?            @relation(fields: [employeesId], references: [id])
  goal                   Goal?                 @relation(fields: [goalId], references: [id])
  industry               Industry?             @relation(fields: [industryId], references: [id])
  initiative             Initiative?           @relation(fields: [initiativeId], references: [id])
  reportingPeriod        ReportingPeriod?      @relation(fields: [reportingPeriodId], references: [id])
  scope1And2             Scope1And2?           @relation(fields: [scope1And2Id], references: [id])
  scope1                 Scope1?               @relation(fields: [scope1Id], references: [id])
  scope2                 Scope2?               @relation(fields: [scope2Id], references: [id])
  scope3                 Scope3?               @relation(fields: [scope3Id], references: [id])
  statedTotalEmissions   StatedTotalEmissions? @relation(fields: [statedTotalEmissionsId], references: [id])
  turnover               Turnover?             @relation(fields: [turnoverId], references: [id])
  user                   User                  @relation("metadata_user_id", fields: [userId], references: [id])
  verifiedBy             User?                 @relation("metadata_verified_by", fields: [verifiedByUserId], references: [id])
}

model User {
  id             String     @id @default(cuid())
  email          String?
  name           String     @unique
  githubId       String?    @unique
  githubImageUrl String?
  bot            Boolean    @default(false)
  displayName    String?
  updated        Metadata[] @relation("metadata_user_id")
  verified       Metadata[] @relation("metadata_verified_by")
}
